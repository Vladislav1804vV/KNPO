#include <QCoreApplication>
#include "main.h"

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    if(argc > 1)
        JavaParssing(argv[1]);

    printf("Done");

    return a.exec();
}


void JavaParssing(const char *fileName)
{
    //Получить список массивов, содержащих строки кода каждого файла на языке Java
    QList <QStringList> list = getFilesArray(openAllFiles(absolutePath(fileName)));
    deleteComments(list);           //Удалить комментарии
    deleteAnnotations(list);        //Удалить аннотации
    structuralViewOfCode(list);     //Привести код к структурному виду
    //Выделить пакеты и импорты
    QList <QStringList>  list2 = takePackageAndImports(list);
    //Создать файл для записи данных (классов) в формате Xml и определить класс для данной реализации
    QFile file("xml.txt");
    file.open(QIODevice::WriteOnly);
    QXmlStreamWriter xmlWriter(&file);
    xmlWriter.setAutoFormatting(true);
    //Записать данные в формате XML
        //Начать документ
        xmlWriter.writeStartDocument();
            //Определить корневой элемент программы
            xmlWriter.writeStartElement("program");
            int count = 0;
            QString strPack;
            for(int i = 0; i < list.size(); i++)    //Для всех файлов программы определить общее кол-во классов
            {
                strPack = list2[i][0];
                list2[i].removeAll("");
                count += findClasses(list[i], list2[i].size(), list[i].size()-1).size();
            }
            //Записать атрибут кол-ва классов
            xmlWriter.writeAttribute("count", QString::number(count));
            for(int i = 0; i < list.size(); i++)    //Для всех файлов программы распарсить классы
            {
                parsingClasses(list[i], strPack, list2[i].size(), xmlWriter);
            }
            //Закрыть корневой элемент программы
            xmlWriter.writeEndElement();
        //Закончить документ
        xmlWriter.writeEndDocument();
    //Закрыть файл
    file.close();
    //Создать файл для записи данных (импортов) в формате Xml и определить класс для данной реализации
    QFile file2("import.txt");
    file2.open(QIODevice::WriteOnly);
    QXmlStreamWriter xmlWriter2(&file2);
    xmlWriter2.setAutoFormatting(true);
    //Записать данные в формате Xml
        //Начать документ
        xmlWriter2.writeStartDocument();
            //Определить корневой элемент программы
            xmlWriter2.writeStartElement("import");
            for(int i = 0; i < list2.size(); i++)   //Для всех файлов программы определить импорты
            {
                int j = 0;
                QString strPack = "";
                if(list2[i][j] != "")
                {
                    strPack = list2[i][j];
                    j++;
                }
                for(j; j < list2[i].size(); j++)
                {
                    //Если в текущем файле отсутствует название пакета, определить элемент импорта без его использования
                    if(strPack == "")
                        xmlWriter2.writeStartElement(list2[i][j]);
                    //Иначе, определить элемент импорта, приписав в начале каждого импорта название пакета
                    else
                        xmlWriter2.writeStartElement(strPack + '.' + list2[i][j]);
                    //Закрыть элемент импорта
                    xmlWriter2.writeEndElement();
                }
            }

            //Закрыть коревой элемент программы
            xmlWriter2.writeEndElement();
        //Закончить документ
        xmlWriter2.writeEndDocument();
    //Закрыть файл
    file2.close();
}

HANDLE openFile(QString Filename)
{
    //Получить дескриптор открытого файла
    HANDLE myFile = CreateFileA(Filename.toStdString().c_str(), GENERIC_READ, NULL, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    //Вернуть дескриптор открытого файла
    return myFile;
}

QList <HANDLE> openAllFiles(QString Filename)
{
    //Получить дескриптор открытого файла
    HANDLE myFile = CreateFileA(Filename.toStdString().c_str(), GENERIC_READ, NULL, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    //Если дескриптор получен, получить заданные пути в файле и дескрипторы файлов по данным путям
    if(myFile != INVALID_HANDLE_VALUE)
    {
        //Прочитать данные в файле в отдельную строку
        const int size = GetFileSize(myFile, NULL) + 1;
        char str[size];
        str[size-1] = '\0';
        ReadFile(myFile, str, size, NULL, NULL);
        //Разбить строку по символу переноса новой строки
        QString string = QString::fromUtf8(str);
        QStringList list = string.split("\n");
        for(int i = 0; i < list.size(); i++) //Для каждой строки файла удалить лишние белые разделители
            list[i] = list[i].simplified();
        //Удалить пустые строки
        list.removeAll("");
        for(int i = 0; i < list.size(); i++)    //Для каждого пути получить его абсолютный путь
            list[i] = absolutePath(list[i]);
        //Удалить одинаковые пути
        list.removeDuplicates();
        //Получить дескрипторы всех файлов по заданным путям
            QList <HANDLE> list_handle;
            for(int i = 0; i < list.size(); i++)    //Для каждого пути проверить на принадлежность файла к языку Java и получить его дескриптор
            {
                //Проверить на принадлежность текущего файла к языку Java
                fileExtensionJava(list[i]);
                //Получить дескриптор текущего открытого файла
                HANDLE file = openFile(list[i]);
                //Если дескриптор текущего файла получен, записать его в список дескрипторов
                if(file != INVALID_HANDLE_VALUE)
                    list_handle << file;
                //Иначе, закрыть дескриптор текущего файла и объявить соответствующую ошибку
                else
                {
                    //Закрыть дескриптор текущего файла
                    CloseHandle(file);
                    //Объявить ошибку не существования текущего файла
                    errorMessage(list[i] + " does not exist");
                }
            }
        //Закрыть дескриптор файла с путями к файлам программы
        CloseHandle(myFile);
        //Если имеются пути к файлам, определить принадлежность файлов к одному проекту и вернуть список дескрипторов
        if(list.size())
        {
            //Определить принадлежность файлов к одному проекту
            sameProject(list);
            //Вернуть список дескрипторов
            return list_handle;
        }
        //Иначе, объявить ошибку пустого файла
        else
            errorMessage(Filename + "  is empty");

    }
    //Закрыть дескриптор файла с путями к файлам программы
    CloseHandle(myFile);
    //Объявить ошибку не существования файла с путями к файлам программы
    errorMessage(Filename + " does not exist");
}

QString absolutePath(QString Filename)
{
    //Определить текущий путь исполняемого файла
    QString cur_dir;
    cur_dir = QDir::currentPath();
    //Если заданный путь не является абсолютным, сделать его таковым, используя текущий путь исполняемого файла
    QString strong_filename;
    if (Filename[1] != ':')
    {
        //Вставить в начало строки текущий путь исполняемого файла
        strong_filename.prepend(cur_dir);
        //Вставить в конец строки символ '\'
        strong_filename.append("\\");
    }
    //Иначе, очистить строку
    else
        strong_filename.clear();
    //Вставить в конец строки заданный путь
    strong_filename.append(Filename);
    //Вернуть абсолютный путь
    return strong_filename;
}

void fileExtensionJava(QString path)
{
    //Определить позицию последнего вхождения символа '.' в заданном пути
    int point = path.lastIndexOf('.');
    //Если символ '.' найден, проверить строку на соответствующее вхождение
    if (point != NULL)
    {
        //Если строка после вхождения не соответсвует расширению языка Java, объявить ошибку непринадлежности файла к языку Java
        if(path.mid(point) != ".java")
            errorMessage("extension does not match the Java language extension in " + path);
    }
    //Иначе, объявить ошибку отсутствия расширения в заданном файле
    else
        errorMessage("missing file extension in " + path);
}

void errorMessage(QString message)
{
    //Напечатать сообщение об ошибке
    printf("%s\n", message.toStdString().c_str());
    _getch();
    //Досрочный выход из программы
    exit(0);
}

void sameProject(QStringList listFiles)
{
    QStringList srcList;
    for(int i = 0; i < listFiles.size(); i++) //Для всех путей файлов программы определить строки после вхождения строки "src", заключенной в символы обратной слэша
    {
        //Определить абсолютный путь текущего файла
        QString srcPath = absolutePath(listFiles[i]);
        //Если текущий путь файла содержит строку "src",заключенную в символы обратного слэша, выделить строку после данной
        if(srcPath.contains("\\src\\"))
        {
            //Определить позицию вхождения строки "src",заключенной в символы обратного слэша
            int src = srcPath.indexOf("\\src\\");
            //Выделить строку после данной
            srcPath.truncate(src+4);
            //Записать полученную строку
            srcList << srcPath;
        }
        //Иначе, объявить ошибку непринадлежности файлов к одному проекту
        else
            errorMessage("files do not belong to one project");
    }
    //Выделить строку первого пути после заданного вхождения
    QString comparePath = srcList[0];
    for(int i = 1; i < srcList.size(); i++) //Для всех полученных строк, кроме первой, сравнить их с первой строкой
        //Если текущая строка не равна первой, объявить ошибку непринадлежности файлов к одному проекту
        if(srcList[i] != comparePath)
            errorMessage("files do not belong to one project");
}

QStringList fileToStringList(HANDLE handle)
{
    //Прочитать данные в файле в отдельную строку
    const int size = GetFileSize(handle, NULL) + 1;
    char str[size];
    str[size-1] = '\0';
    ReadFile(handle, str, size, NULL, NULL);
    //Разбить строку по символу переноса новой строки
    QString string = QString::fromUtf8(str);
    QStringList list = string.split("\n");
    for(int i = 0; i < list.size(); i++) //Для каждой строки файла удалить лишние белые разделители
        list[i] = list[i].simplified();
    //Удалить пустые строки
    list.removeAll("");
    //Вернуть список строк файла
    return list;
}

QList <QStringList> getFilesArray(QList <HANDLE> list_handle)
{
    QList <QStringList> list;
    for(int i = 0; i < list_handle.size(); i++) //Для каждого дескриптора открытого файла, открыть файл языка Java в список строк кода
    {
        //Открыть файл языка Java в строки кода
        list << fileToStringList(list_handle[i]);
        //Закрыть дескриптор открытого файла
        CloseHandle(list_handle[i]);
    }
    //Вернуть список строк кода
    return list;
}

void deleteComments(QList <QStringList> &list)
{
    //Для всех файлов программы удалить комментарии
    {
        //Для каждой строки кода файла программы найти комментарий
        {
            //Если текущая строка кода файла программы содержит однострочный комментарий или начало многострочного, удалить комментарий, определив его вид
            {
                //Определить вид комментария
                    //Если однострочный комментарий не найден, считать наличие многострочного комментария
                    //Иначе, если многострочный комментарий не найден, считать наличие однострочного комментария
                    //Иначе, если признак однострочного комментария находится раньше признака многострочного, считать наличие однострочного комментария
                    //Иначе, считать наличие многострочного комментария
                //Если комментарий не "закавычен", удалить комментарий
                {
                    //Если определен однострочный комментарий, удалить его
                    //Иначе, если определен многострочный комментарий, определить конец комментария и удалить его
                    {
                        //Если в текущей строке не содержится конец комментария, найти конец, удаляя все предыдущие строки кода
                        {
                            //Удалить текущую строку кода
                            //Для каждой строки кода от последующей до последней найти конец комментария
                                //Если текущая строка содержит конец многострочного комментария, удалить комментарий
                                {
                                    //Определить позицию конца комментария
                                    //Если конец комментария не "закавычен", удалить комментарий
                                }
                                //Иначе, удалить строку целиком
                        }
                        //Иначе, удалить комментарий
                    }
                }
                //Иначе, инкрементировать позицию найденного комментария
            }
        }
        //Для каждой строки кода программы удалить лишние белые разделители
        //Удалить все пустые строки кода программы
    }
}

bool quotedThing(QStringList list, int index, int position)
{
    //Убрать правую часть строки от заданной позизиции
    //Считать счетчик кол-ва кавычек равным 0
    //Для каждой строки кода программы от первой и до заданной (включительно) подсчитать кол-во кавычек
    {
        //Прибавить к обещему кол-ву кавычек число кавычек, входящих в текущую строку
        //Если в текущую строку входят экранированные кавычки, вычесть их кол-во из общего кол-ва кавычек
    }
    //Если общее кол-во кавычек нечетное, вернуть признак "закавыченности" символа в заданной строке и позиции
    //Иначе, вернуть признак отсутствия "закавыченности"
}

bool thingInRoundBrackets(QStringList list, int index, int position)
{
    //Убрать правую часть строки от заданной позизиции
    //Считать счетчик кол-ва открытых скобок равным 0
    //Считать счетчик кол-ва закрытых скобок равным 0
    //Принять переменную для позиций вхождений
    //Для каждой строки кода программы от первой и до заданной (включительно) подсчитать кол-во открытых и закрытых скобок по отдельности
    {
        //Обнулить позицию вхождения
        //Для текущей строки прибавить кол-во "незакавыченных" открытых скобок
        {
            //Определить позицию вхождения открытой скобки
            //Если данная скобка не "закавычена", инкрементировать общее кол-во открытых скобок
            //Инкрементировать позицию текущего вхождения открытой скобки
        }
        //Обнулить позицию вхождения
        //Для текущей строки прибавить кол-во "незакавыченных" закрытых скобок
        {
            //Определить позицию вхождения закрытой скобки
            //Если данная скобка не "закавычена", инкрементировать общее кол-во закрытых скобок
            //Инкрементировать позицию текущего вхождения закрытой скобки
        }
    }
    //Если общее кол-во открытых скобок не равняется общему кол-ву закрытых скобок, вернуть признак заключения символа в скобках в заданной строке и позиции
    //Иначе, вернуть признак отсутствия заключения символа в скобках
}

void deleteAnnotations(QList <QStringList> &list)
{
    //Для всех файлов программы удалить аннотации
    {
        //Для кажой строки кода текущего файла программы, удалить аннотации
        {
            //Если текущая строка содержит символ начала аннотации '@'
            {
                //Определить позицию вхождения символа начала аннотации
                //Принять массив для хранения индекса строки и позиции начала аннотации
                //Принять массив для хранения индекса строки и позиции конца аннотации
                //Если позиция вхождения символа не "закавычена" и не заключена в скобки, определить начало и конец аннотации и удалить ее
                {
                    //Считать индекс строки начала аннотации равным индексу текущей строки
                    //Считать позицию в строке начала аннотации равным позиции вхождения символа
                    //Если текущая строка непустая и заканчивается модификатором доступа аннотации, определить индекс строки и позиции начала аннотации
                    {
                        //Если текущая строка заканчивается модификатором доступа "public", считать позицию начала аннотации началом модификатора доступа "public"
                        //Иначе, если текущая строка заканчивается модификатором доступа "private", считать позицию начала аннотации началом модификатора доступа "private"
                        //Считать индекс строки начала аннотации равным индексу текущей строки
                    }
                    //Иначе, если индекс текущей строки не равен 0, определить индекс строки и позиции начала аннотации
                    {
                        //Если предыдущая строка заканчивается модификатором доступа "public", определить индекс строки и позиции начала аннотации
                        {
                            //Считать индекс строки начала аннотации равным индексу предыдущей строки
                            //Считать позицию в строке начала аннотации началом модификатора доступа "public"
                        }
                        //Иначе, если предыдущая строка заканчивается модификатором доступа "private", определить индекс строки и позиции начала аннотации
                        {
                            //Считать индекс строки начала аннотации равным индексу предыдущей строки
                            //Считать позицию в строке начала аннотации началом модификатора доступа "private"
                        }
                    }
                    //Удалить в текущей строке лишние белые разделители
                    //Если позиция вхождения символа начала аннотации находится в конце строки, перейти к следующей строке, обнуляя позицию вхождения
                    {
                        //Инкременитировать индекс текущей строки
                        //Обнулить позицию вхождения
                    }
                    //Иначе, инкременитровать позицию вхождения
                    //Удалить в текущей строке лишние белые разделители
                    //Если текущая позиция вхождения содержит пробельный симмвол, инкременитровать позицию вхождения
                    //Если строка от заданной позиции начинается строкой "interface" и не является концом текущей строки, сместить позицию вхождения на следующее слово после слова "interface"
                    //Иначе, если строка от заданной позиции заканичает текущую строку словом "interface", перейти на следующую строку, обнуляя позицию вхождения
                    {
                        //Инкременитировать индекс текущей строки
                        //Перейти к следующему буквенному символу, обнулив позицию вхождения
                    }
                    //Найти позицию первого пробельного символа от заданной позиции
                    //Если позиция конца аннотации является концом текущей строки, определить позицию конца аннотации и перейти на следующую строку
                    {
                        //Считать индекс строки конца аннотации равным индексу текущей строки
                        //Считать позицию в строке конца аннотации концом текущей строки
                        //Инкременитировать индекс текущей строки
                        //Перейти к следующему буквенному символу, обнулив позицию вхождения
                    }
                    //Иначе, определить позицию конца аннотации на основе найденной позиции пробельного символа
                    {
                        //Определить позицию первого пробельного символа от начала текущей строки
                        //Считать индекс строки конца аннотации равным индексу текущей строки
                        //Считать позицию в строке конца аннотации позицию до первого пробельного символа от начала текущей строки
                        //Инкрементировать позицию вхождения
                    }
                    //Если текущая позиция вхождения является началом аргумента аннотации или началом тела в случае аннотации интерфейса, определить позицию конца аннотации
                    {
                        //Если текущая позиция вхождения является началом аргумента аннотации, определить позицию конца аннотации
                        //Иначе, если текущая позиция вхождения является началом тела аннотации, определить позицию конца аннотации
                        //Считать индекс строки конца аннотации равным найденному индексу
                        //Считать позицию в строке конца аннотации равной найденной позиции
                    }
                    //Считать индекс текущей строки равным индексу начала аннотации
                    //Если аннотация находится на одной строке, удалить ее, зная начало и конец аннотации
                    //Иначе, удалить аннотацию, удаляя строки до ее конца
                    {
                        //Вырезать строку от начала аннотации до конца текущей строки
                        //Инкрементировать индекс текущей строки
                        //Пока индекс текущей строки не равен мндексу конца аннотации, удалить строку и перейти к следующей
                        {
                            //Удалить текущую строку
                            //Инкрементировать индекс текущей строки
                        }
                        //Вырезать последнюю строку, содержащую аннотация, от начала текущей строки до конца аннотации
                    }
                    //Декрементировать индекс текущей строки
                }
            }
        }
    //Для кажой строки кода текущего файла программы, удалить лишние белые разделители
    //Удалить пустые строки
    }
}


QList <int> findClosingSymbol(QStringList list, int startPosition, int indexBrace, QChar closeSymbol)
{
    //Определить открывающийся символ
    //Считать счетчик открытых/закрытых символов равным 1
    //Считать индексы открытого и закрытого символов равнымм заданному индексу
    //Для каждой строки кода текущего файла программы от заданной до последней, определить позицию закрывающегося символа
    {
        //Если в текущей строке содержутся символы закрытия, определить значение счетчика открытых/закрытых символов
        {
            //Определить кол-во символов зыкрытия
            //Для каждого найденного символа закрытия определить символы открытия в их промежутках
            {
                //Определить индекс текущего символа закрытия
                //Если индекс текущей строки равен заданному индексу, выделить подстроку между индексом открытого и закрытого символов (не включая их)
                //Иначе, выделить подстроку между индексом открытого и закрытого символов (не включая индекс закрытого)
                //Определить кол-во символов открытия в найденном промежутке
                //Для каждого найденного символа открытия определить его "закавыченность"
                {
                    //Определить индекс текущего символа открытия
                    //Если индекс текущей строки равен заданному индексу, инкрементировать индекс открытого символа
                    //Если текущий символ открытия не "закавычен", инкрементировать счетчик открытых/закрытых символов
                    //Инкрементировать индес открытого символа
                }
                //Если текущий символ закрытия не "закавычен", декрементировать счетчик открытых/закрытых символов
                //Если счетчик открытых/закрытых символов равен 0, вернуть позицию закрывающегося символа
                //Инкрементировать индес закрытого символа
            }
        }
        //Иначе, определить значение счетчика, уменьшив его на кол-во найденных "незакавыченных" символов открытия
        {
            //Если индекс текущей строки равен заданному индексу, декрементировать счетчик открытых/закрытых символов
            //Если длина текущей строки равна 1, определить наличие в ней символа открытия
            //Иначе, определить кол-во символов открытия
            //Для каждого найденного символа открытия определить "незакавыченные" символы открытия
            {
                //Определить индекс текущего символа открытия
                //Если текущий символ открытия не "закавычен", инкрементировать счетчик открытых/закрытых символов
                 //Инкрементировать индекс открытого символа
            }
            //Декрементировать индекс открытого символа
        }
        //Если индекс открытого символа не равен индексу закрытого символа, определить кол-во символов открытия
        //Для каждого найденного символа открытия определить значение счетчика открытых/закрытых символов
        {
            //Определить индекс текущего символа открытия
            //Если текущий символ открытия не "закавычен", инкрементировать счетчик открытых/закрытых символов
        }
        //Обнулить индексы символов открытия и закрытия
    }
    //Вернуть неопределенную ошибку
}

void structuralViewOfCode(QList <QStringList> &list)
{
    //Для всех файлов программы привести код к структурному виду
    {
        //"Склеить" строки кода текущего файла программы в одну строку
        //Удалить код текущего файла
        //Разместить каждый простой оператор и символ тела блока в отдельных строках
        //Для каждой строки кода текущего файла программы отредактировать неправильное размещение кода в отдельных строках
        {
            //Удалить пустые строки
            //Определить последний символ в текущей строке
            //Если символ пустого оператора "закавычен" или заключен в скобках, "приклеить" к текущей строке последующую
            //Иначе, если символ тела блока "закавычен" или заключен в скобках, "приклеить" к текущей строке предыдущую и последующую
            //Иначе, если символ равен символу равенства, приклеить" к текущей строке последующие до найденной строки
        }
        //Удалить строки состояющие только из символа пустого оператора
    }
}

QList <QStringList> takePackageAndImports(QList <QStringList> list)
{
    //Для всех файлов программы определить "импорты" и наличие/отсутствие пакета
    {
        //Если первая строка кода текущего файла программы начинается словом "package", сохранить название пакета и перейти к следующей строке
        //Иначе, сохранить название пакета как пустую строку
        //Пока последующие строки начинаются словом "import", сохранять названия "импортов"
        //Сохранить данные текущего файла об "импортах" и наличии/отсутствии пакета
    }
    //Вернуть данные об "импортах" и наличии/отсутствии пакета для всех файлов программы
}

void parsingClasses(QStringList list, QString namePackage, int startPos, QXmlStreamWriter &xmlWriter)
{
    //Определить позиции заголовков всех классов заданного файла программы
    //Для все найденных классов провести их "парсинг"
    {
        //Определить строку, содержащую имя заголовка текущего класса и имя пакета при его наличии
            //Если название пакета отсутствует, считать строку состоящей только из имени заголовка текущего класса
            //Иначе, к имени пакета добавить имя заголовка текущего класса
        //Определить элемент программы, содержащий все найденные классы
            //Определить наличие операторов "implements" и "extends"
                //Если после имени класса имеется оператор, выделить строку после имени класса
                    //Для всех частей строки после имени класса склеить последующие строки
                //Если выделенная строка начинается оператором "implements", определить его как атрибут элемент программы
                //Иначе, если выделенная строка начинается оператором "extends", определить его как атрибут элемент программы
            //Обработать все вложенные классы
                //Найти позиции заголовков всех вложенных классов текущего класса
                //Определить атрибут, содержащий кол-во вложенных классов
            //Обработать все поля текущего класса
                //Найти позиции всех полей текущего класса заданного файла программы
                //Определить элемент программы, содержащий все найденные поля текущего класса
                //Определить атрибут, содержащий кол-во полей текущего класса
                //"Распарсить" поля текущего класса
                //Закрыть элемент программы, содержащий все найденные поля текущего класса
            //Обработать все методы текущего класса
                //Найти позиции всех методов текущего класса заданного файла программы
                //Определить элемент программы, содержащий все найденные методы текущего класса
                //Определить атрибут, содержащий кол-во методов текущего класса
                //"Распарсить" методы текущего класса
                //Закрыть элемент программы, содержащий все найденные методы текущего класса
            //Если найденны вложенные классы, "распарсить" их
        //Закрыть элемент программы, содержащий все найденные классы
    }
}

QList <int> findClasses(QStringList list, int start, int end)
{
    //Для всех строк кода заданного файла программы от заданного начала и конца определить позиции всех заголовков классов
    {
        //Если текущая строка содержит строку "class" и она не "закавычена" и не заключена в скобках, определить позицию найденного заголовка класса
        {
            //Сохранить позицию заголовка класса как индекс текущей строки
            //Найти конец тела данного класса
        }
    }
    //Вернуть позиции всех заголовков классов заданного файла программы
}

QList <int> findFields(QStringList list, int start, int end)
{
    //Для всех строк кода заданного файла программы от заданного начала и конца определить позиции всех полей
    {
        //Если текущая строка содержит "незакавыченную" круглую открывающуюся скобку и перед ней есть символ "равно", определить все поля в строке
        {
            //Если текущая строка содержит символ "запятая", определить все поля в строке
            {
                //Заменить все фигурные и квадратные скобки на аналогичные круглые скобки
                //Разбить строку по запятым
                //Сохранить первую часть разбиения
                //Для всех частей разбиения, определить "закавыченность" запятых, "приклеивая" к первой части разбиения текущие
                {
                    //"Приклеить" текущую строку
                    //Если последняя запятая в строке не "закавычена" и не заключена в скобках, сохранить позицию поля как индекс текущей строки
                }
            }
            //Сохранить позицию поля как индекс текущей строки
        }
        //Иначе, если текущая строка не содержит круглую открывающуюся и фигурную скобки, определить все поля в строке
        {
            //Если текущая строка содержит "незакавыченное" слово "class" и последующая строка начинается символом открытия тела, определить конец тела
            //Иначе, если текущая строка содержит "незакавыченное" слово "interface" и последующая строка начинается символом открытия тела, определить конец тела
            //Иначе, если текущая строка не начинается символами открытия и закрытия тела и не равна строке "static",  определить все поля в строке
            {
                //Если текущая строка содержит символ "запятая", определить все поля в строке
                {
                    //Создать копию кода текущего файла программы
                    //Заменить все фигурные и квадратные скобки на аналогичные круглые скобки в данной копии
                    //Разбить текущую строку копии по запятым
                    //Сохранить первую часть разбиения
                    //Для всех частей разбиения, определить "закавыченность" запятых, "приклеивая" к первой части разбиения текущие
                    {
                         //"Приклеить" текущую строку
                        //Если последняя запятая в строке не "закавычена" и не заключена в скобках, сохранить позицию поля как индекс текущей строки
                    }
                }
                //Сохранить позицию поля как индекс текущей строки
            }
        }
        //Иначе, если текущая строка равняется фигурной открывающейся скобке, определить конец тела
        //Иначе, если последующая строка равняется фигурной открывающейся скобке, определить конец тела
    }
    //Вернуть позиции всех полей заданного файла
}

QList <int> findMethods(QStringList list, int start, int end)
{
    //Для всех строк кода заданного файла программы от заданного начала и конца определить позиции всех методов
    {
        //Если текущая строка содержит "незакавыченную" круглую открывающуюся скобку и перед ней нет символа "равно", определить метод
        {
            //Если текущая строка содержит "незакавыченное" слово "class" и последующая строка начинается символом открытия тела, определить конец тела
            //Иначе, если текущая строка не начинается символами открытия и закрытия тела, сохранить позицию метода как индекс текущей строки и при необходимости определить конец тела
            {
                //Сохранить позицию поля как индекс текущей строки
                //Если последующая строка начинается символом открытия тела и текущая строка не заканчивается символом пустого оператора, определить конец тела
            }
        }
        //Иначе, если текущая строка содежит "незакавыченное" слово "class" и последующая строка начинается символом открытия тела, определить конец тела
        //Иначе, если текущая строка равняется символу открытия тела, сохранить позицию метода как индекс текущей строки и определить конец тела
        {
            //Сохранить позицию поля как индекс текущей строки
            //Определить конец тела
        }
    }
    //Вернуть позиции всех методов заданного файла
}

void parsingFields(QStringList list, QList <int> listFields, QXmlStreamWriter &xmlWriter)
{
    //Для всех заданных позиций полей, удалить повторяющиеся
    //Для всех заданных позиций полей, провести их "парсинг"
    {
        //Создать копию текущей строки
        //Вставить перед и после следующих символов: "равно", открытые и закрытые угловые, квадратные скобки, "запятая" пробельные символы
        //Разбить строку по пробельному символу
        //Вернуть строку к первоначальному виду, удалив вставленные пробельные символы
        //Обнулить переменную для хранения индексов составляющих частей в разбиении
        //Считать, что значение у поля отсутствует
        //Пока текущая часть разбиения строки по пробельному символу содержит модификатор доступа или другой модификатор перейти к следующей
        //Сохранить позиция начала типа поля как текущий индекс составляющей части в разбиении
        //Сохранить позицию конца типа поля как позиция начала типа поля
        //Если последующая составляющая часть в разбиении равна открывающейся угловой скобке, переназначить позицию конца типа поля
        {
            //Определить позицию закрывающейся угловой скобки
            //Сохранить позицию конца типа поля как позиция найденной закрывающейся угловой скобки
        }
        //Иначе, если последующая составляющая часть в разбиении равна открывающейся квадратной скобке, переназначить позицию конца типа поля
        {
            //Увеличить индекс составляющих частей в разбиении на 2
            //Пока текущий индекс равен открывающейся или закрывающейся квадратной скобке, инкрементировать индекс составляющих частей в разбиении
            //Декрементировать индекс составляющих частей в разбиении
            //Сохранить позицию конца типа поля как значение индекса составляющих частей в разбиении
        }
        //Если последующая составляющая часть в разбиении равна символу равенства, переназначить позицию конца типа поля
        {
            //Декрементировать индекс составляющих частей в разбиении
            //Сохранить позицию конца типа поля как значение равное -1
        }
        //Определить дополнительный тип поля в случае, когда тип массива определяется после имени поля
            //Если позиция конца типа поля равна -1 и поле заканчивается своим именем, определить дополнительный тип поля
            {
                //Пока после имени поля следуют открывающаяся и закрывающаяся квадратные скобки, вырезать составляющие части разбиения
                {
                    //Прибавить к строке дополнительного типа текущую строку составляющей части разбиения
                    //Удалить текущую строку составляющей части разбиения
                }
            }
        //Определить элемент программы равный имени поля
            //Если у поля отсутствует значение, определить элемент программы равный имени поля
            //Иначе, определить элемент программы равный имени поля и определить значение данного поля
            {
                //Определить элемент программы как строку текущей составляющей части разбиения
                //Считать, что значение поля присутствует
                //Если в одной строке определяется нескольно полей, декрементировать позицию составляющих частей в разбиении
                //Для всех частей разбиения от первого имени поля, выделить все части до конца
                //Вернуть выделенную строку к первоначальному виду, удалив вставленные пробельные символы
            }
        //Выделить первоначальный тип поля
            //Для всех составляющих частей разбиения от идекса начала типа до индекса конца типа, склеить составляющие части
            //Вернуть склеенную  строку к первоначальному виду, удалив вставленные пробельные символы
            //Определить элемент программы равным типу поля
        //Определить модификаторы доступа и другие модификаторы поля
            //Обнулить индекс составляющих частей разбиения
            //Пока текущая часть разбиения строки содержит модификатор доступа или другой модификатор перейти к следующей, определяя их по виду
            {
                //Если текущая часть разбиения строки содержит модификатор доступа, определить его, сохраняя его
                {
                    //Определить элемент программы равный модификатору доступа поля
                    //Сохранить модификатор доступа для других полей, определенных на одной строке
                }
                //Иначе, если текущая часть разбиения строки содержит другой модификатор, определить его, сохраняя его
                {
                    //Определить элемент программы равный найденному модификатору поля
                    //Сохранить найденный модификатор для других полей, определенных на одной строке, учитывая, что их может быть несколько
                }
                //Инкрементировать индекс составляющих частей разбиения
            }
        //Если в одной строке определено несколько полей или первое поле имеет значение, определить все поля с их значениями при наличии
        {
            //Разбить выделенную строку от имени первого поля по "незакавыченным" запятым
            //Если в строке определено только одно поле, определить элемент программы равный значению поля (без символа пустого оператора)
            //Иначе, если определено несколько полей, определить элемент программы равный значению поля
            //Закрыть элемент программы равный значению поля
            //Если в одной строке определено несколько полей, определить все поля с их значениями при наличии
                //Для всех полей кроме первого определить поля
                {
                    //Определить дополнительный тип поля в случае, когда тип массива определяется после имени поля
                        //Вставить перед и после открывающихся и закрывающихся квадратных скобок пробельные символы
                        //Разбить строку по пробельному символу
                        //Вернуть строку к первоначальному виду, удалив вставленные пробельные символы
                        //Если после имени содержится дополнительный тип, выделить его
                        {
                            //Пока после имени поля следуют открывающаяся и закрывающаяся квадратные скобки, вырезать составляющие части разбиения
                            {
                                //Прибавить к строке дополнительного типа текущую строку составляющей части разбиения
                                //Удалить текущую строку составляющей части разбиения
                            }
                            //Склеить оставшиеся части разбиения
                        }
                    //Если текущее поле последнее и не содержит значения, определить элемент программы как имя текущего поля(без символа пустого оператора)
                    //Иначе, определить элемент программы как имя текущего поля
                    //Определить элемент программы равным типу текущего поля
                    //Если в строке определен модификатор доступа, определить его как элемент программы
                    //Для всех других модификаторов определить их как элементы программы
                    //Если текущее поле содержит значение, определить его как элемент программы
                    {
                        //Если текущая строка заканчивается символом пустого оператора, определить элемент программы равный значению поля (без символа пустого оператора)
                        //Иначе, определить элемент программы равный значению поля
                    }
                    //Закрыть элемент программы равный имени текущего поля
                }
        }
        //Иначе, закрыть элемент программы равный имени певого поля
    }
}

void parsingMethods(QStringList list, QList <int> listMethods, QXmlStreamWriter &xmlWriter)
{
    //Для всех заданных методов, провести их "парсинг"
    {
        //Если текущий метод начинается открывающейся фигурной скобкой, считать, что это блок-инициализации
        {
            //Определить элемент программы как имя для блока-инициализации
            //Считать блок-инициализации нестатическим
            //Если перед началом тела блока-инициализации содержится модификатор "static", считать блок-инициализации статическим
            //Определить атрибут программы как тип блока-инициализации
            //Найти конец тела блока-инициализации
            //Для всех строк между началом и концом тела блока-инициализации выделить их в список
            //Склеить строки списка символом переноса строки
            //Определить элемент программы равным значению блока-инициализации
            //Закрыть элемент программы равный имени для блока-инициализации
            //Перейти к следующей итерации цикла
        }
        //Создать копию текущей строки
        //Вставить перед и после следующих символов: открытые и закрытые угловые, квадратные, круглые скобки, "запятая" пробельные символы
        //Разбить строку по пробельному символу
        //Вернуть строку к первоначальному виду, удалив вставленные пробельные символы
        //Обнулить переменную для хранения индексов составляющих частей в разбиении
        //Пока текущая часть разбиения строки по пробельному символу содержит модификатор доступа или другой модификатор перейти к следующей
        //Сохранить позиция начала типа метода как текущий индекс составляющей части в разбиении
        //Сохранить позицию конца типа поля как позиция начала типа поля
        //Если последующая составляющая часть в разбиении равна открывающейся угловой скобке, переназначить позицию конца типа поля
        {
            //Определить позицию закрывающейся угловой скобки
            //Сохранить позицию конца типа поля как позиция найденной закрывающейся угловой скобки
        }
        //Иначе, если последующая составляющая часть в разбиении равна открывающейся квадратной скобке, переназначить позицию конца типа поля
        {
            //Увеличить индекс составляющих частей в разбиении на 2
            //Пока текущий индекс равен открывающейся или закрывающейся квадратной скобке, инкрементировать индекс составляющих частей в разбиении
            //Декрементировать индекс составляющих частей в разбиении
            //Сохранить позицию конца типа поля как значение индекса составляющих частей в разбиении
        }
        //Выделить тип метода
            //Для всех составляющих частей разбиения от идекса начала типа до индекса конца типа, склеить составляющие части
            //Вернуть склеенную  строку к первоначальному виду, удалив вставленные пробельные символы
            //Если последующая составляющая часть в разбиении не равна открывающейся круглой скобке, определить элемент и атрибут программы
            {
                //Определить элемент программы равный имени метода
                //Определить атрибут программы равный типу метода
            }
            //Иначе, если последующая составляющая часть в разбиении равна открывающейся круглой скобке, определить элемент программы равный имени метода
        //Определить модификаторы доступа и другие модификаторы поля
            //Обнулить индекс составляющих частей разбиения
            //Пока текущая часть разбиения строки содержит модификатор доступа или другой модификатор перейти к следующей, определяя их по виду
            {
                //Если текущая часть разбиения строки содержит модификатор доступа, определить его
                //Иначе, если текущая часть разбиения строки содержит другой модификатор, определить его
                //Инкрементировать индекс составляющих частей разбиения
            }
        //Определить параметры текущего метода
            //Найти позицию начала парметров
            //Найти позицию конца парметров
            //Выделить строку с парметрами метода
            //Разбить строку на отедьные парметры метода
            //Для всех парметров метода определить их как атрибуты элемента программы
        //Определить наличие оператора "throws" у метода
            //Выделить строку после парметров метода
            //Если выделенная строка начинается оператором "throws", опредлить его как атрибут элемента программы
        //Определить тело метода
            //Если заголовок метода не является прототипом, найти начало и конец метода, определив его
            {
                //Найти конец тела метода
                //Для всех строк тела метода сохранить их в список строк
                //Склеить сохраненные строки символом переноса новой строки
                //Определить тело метода как значение элемента программы
            }
        //Закрыть элемент программы равный имени метода
    }
}

QStringList correctlyBrokenByCommas(QString value)
{
    //Вставить перед открывающимися фигурными и угловыми скобками открывающиеся круглые скобки и после соответствующие круглые скобки
    //Определить кол-во запятых в строке
    //Считать переменную для хранения индекса запятых равным 0
    //Для всего кол-ва запятых определить их "незаквыченность" и заключенность в скобки
    {
        //Определить индекс текущей запятой в строке
        //Если найденная запятая не "закавычена" и не заключена в скобки, вставить после найденной запятоя символ переноса новой строки
        //Инкременитровать индекс запятых
    }
    //Вернуть строку к первоначальному виду, удалив вставленные круглые скобки
    //Разбить строку по запятой с символом переноса новой строки
    //Вернуть список разбитых строк
}
